<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qqmlcomponent.cpp -->
  <title>Component QML Type | Qt QML 5.11</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.11</a></td><td ><a href="qtqml-index.html">Qt QML</a></td><td ><a href="qtqml-qmlmodule.html">QML Types</a></td><td >Component QML Type</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.11.1 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
  <h3><a name="toc">Contents （目录）</a></h3>
  <ul>
    <li class="level1"><a href="#properties">Properties （属性）</a></li>
    <li class="level1"><a href="#attached-signals">Attached Signals （附加信号）</a></li>
    <li class="level1"><a href="#methods">Methods （方法）</a></li>
    <li class="level1"><a href="#details">Detailed Description （详细描述）</a></li>
    <li class="level2"><a href="#creation-context">Creation Context （创建上下文）</a></li>
  </ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Component QML Type</h1>
<span class="subtitle"></span>
<!-- $$$Component-brief -->
<p>Encapsulates a QML component definition. <a href="#details">More...</a></p>
封装QML组件定义。<a href="#details">更多...</a><!-- @@@Component -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Import Statement（导入声明）:</td><td class="memItemRight bottomAlign"> import QtQml 2.11</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Instantiates（实例化）:</td><td class="memItemRight bottomAlign"> <a href="qml-qtqml-component.html"><a href="qqmlcomponent.html">QQmlComponent</a></td></tr></table></div><ul>
<li><a href="qml-qtqml-component-members.html">List of all members, including inherited members</a></li>
<li><a href="qml-qtqml-component-members.html">所有成员的列表，包括继承的成员</a></li>
</ul>
<a name="properties"></a>
<h2 id="properties">Properties （属性）</h2>
<ul>
<li class="fn"><b><b><a href="qml-qtqml-component.html#progress-prop">progress</a></b></b> : real</li>
<li class="fn"><b><b><a href="qml-qtqml-component.html#status-prop">status</a></b></b> : enumeration</li>
<li class="fn"><b><b><a href="qml-qtqml-component.html#url-prop">url</a></b></b> : url</li>
</ul>
<a name="attached-signals"></a>
<h2 id="attached-signals">Attached Signals （附加信号）</h2>
<ul>
<li class="fn"><b><b><a href="qml-qtqml-component.html#completed-signal">completed</a></b></b>()</li>
<li class="fn"><b><b><a href="qml-qtqml-component.html#destruction-signal">destruction</a></b></b>()</li>
</ul>
<a name="methods"></a>
<h2 id="methods">Methods （方法）</h2>
<ul>
<li class="fn">object <b><b><a href="qml-qtqml-component.html#createObject-method">createObject</a></b></b>(QtObject <i>parent</i>,  object <i>properties</i>)</li>
<li class="fn">string <b><b><a href="qml-qtqml-component.html#errorString-method">errorString</a></b></b>()</li>
<li class="fn">object <b><b><a href="qml-qtqml-component.html#incubateObject-method">incubateObject</a></b></b>(Item <i>parent</i>,  object <i>properties</i>,  enumeration <i>mode</i>)</li>
</ul>
<!-- $$$Component-description -->
<a name="details"></a>
<h2 id="details">Detailed Description （详细说明）</h2>
<p>Components are reusable, encapsulated QML types with well-defined interfaces.</p>
<p>Components are often defined by <a href="qtqml-documents-topic.html">component files</a> - that is, <code>.qml</code> files. The <i>Component</i> type essentially allows QML components to be defined inline, within a <a href="qtqml-documents-topic.html">QML document</a>, rather than as a separate QML file. This may be useful for reusing a small component within a QML file, or for defining a component that logically belongs with other QML components within a file.</p>
<p>For example, here is a component that is used by multiple <a href="../qtquick/qml-qtquick-loader.html">Loader</a> objects. It contains a single item, a <a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a>:</p>
<p>组件是可重用的，封装的QML类型，具有良好定义的接口。</p>
<p>组件通常由<a href="qtqml-documents-topic.html">组件文件（ component files）</a>定义- 即.qml文件。所述<em>组件</em>类型本质上允许联定义QML组件，一个内<a href="qtqml-documents-topic.html">QML文件</a>，而不是作为单独的文件QML。这对于重用QML文件中的小组件或用于定义逻辑上属于文件中的其他QML组件的组件可能是有用的。</p>
<p>例如，这是一个由多个<a href="../qtquick/qml-qtquick-loader.html">Loader</a>对象使用的组件。它包含一个项目，一个<a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a>：</p>
<pre class="qml">

  import QtQuick 2.0

  <span class="type"><a href="../qtquick/qml-qtquick-item.html">Item</a></span> {
      <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

      <span class="type"><a href="qml-qtqml-component.html">Component</a></span> {
          <span class="name">id</span>: <span class="name">redSquare</span>

          <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a></span> {
              <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
              <span class="name">width</span>: <span class="number">10</span>
              <span class="name">height</span>: <span class="number">10</span>
          }
      }

      <span class="type"><a href="../qtquick/qml-qtquick-loader.html">Loader</a></span> { <span class="name">sourceComponent</span>: <span class="name">redSquare</span> }
      <span class="type"><a href="../qtquick/qml-qtquick-loader.html">Loader</a></span> { <span class="name">sourceComponent</span>: <span class="name">redSquare</span>; <span class="name">x</span>: <span class="number">20</span> }
  }

</pre>
<p>Notice that while a <a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a> by itself would be automatically rendered and displayed, this is not the case for the above rectangle because it is defined inside a <code>Component</code>. The component encapsulates the QML types within, as if they were defined in a separate QML file, and is not loaded until requested (in this case, by the two <a href="../qtquick/qml-qtquick-loader.html">Loader</a> objects). Because Component is not derived from Item, you cannot anchor anything to it.</p>
<p>Defining a <code>Component</code> is similar to defining a <a href="qtqml-documents-topic.html">QML document</a>. A QML document has a single top-level item that defines the behavior and properties of that component, and cannot define properties or behavior outside of that top-level item. In the same way, a <code>Component</code> definition contains a single top level item (which in the above example is a <a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a>) and cannot define any data outside of this item, with the exception of an <i>id</i> (which in the above example is <i>redSquare</i>).</p>
<p>The <code>Component</code> type is commonly used to provide graphical components for views. For example, the <a href="../qtquick/qml-qtquick-listview.html#delegate-prop">ListView::delegate</a> property requires a <code>Component</code> to specify how each list item is to be displayed.</p>
<p><code>Component</code> objects can also be created dynamically using <a href="qml-qtqml-qt.html#createComponent-method">Qt.createComponent()</a>.</p>
<p>请注意，虽然<a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a>本身会自动渲染和显示，但上面的矩形不是这种情况，因为它是在a中定义的Component。该组件将QML类型封装在其中，就好像它们是在单独的QML文件中定义的那样，并且在请求之前不会加载（在这种情况下，由两个<a href="../qtquick/qml-qtquick-loader.html">Loader</a>对象<a href="../qtquick/qml-qtquick-loader.html">加载</a>）。由于Component不是从Item派生的，因此您无法将任何内容锚定到它。</p>
<p>定义a Component类似于定义<a href="qtqml-documents-topic.html">QML文档</a>。QML文档具有单个顶级项，用于定义该组件的行为和属性，并且无法定义该顶级项之外的属性或行为。同样，Component定义包含单个顶级项目（在上面的示例中是一个<a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a>），并且不能定义此项目之外的任何数据，但<em>id</em>（在上面的示例中为<em>redSquare</em>）除外。</p>
<p>该Component类型通常用于为视图提供图形组件。例如，<a href="../qtquick/qml-qtquick-listview.html#delegate-prop">ListView :: delegate</a>属性需要Component指定每个列表项的显示方式。</p>
<p>Component也可以使用<a href="qml-qtqml-qt.html#createComponent-method">Qt.createComponent（）</a>动态创建对象。</p>
<a name="creation-context"></a>
<h3>Creation Context （创建上下文）</h3>
<p>The creation context of a Component corresponds to the context where the Component was declared. This context is used as the parent context (creating a <a href="qtqml-documents-scope.html#component-instance-hierarchy">context hierarchy</a>) when the component is instantiated by an object such as a <a href="../qtquick/qml-qtquick-listview.html">ListView</a> or a Loader.</p>
<p>In the following example, <code>comp1</code> is created within the root context of MyItem.qml, and any objects instantiated from this component will have access to the ids and properties within that context, such as <code>internalSettings.color</code>. When <code>comp1</code> is used as a <a href="../qtquick/qml-qtquick-listview.html">ListView</a> delegate in another context (as in main.qml below), it will continue to have access to the properties of its creation context (which would otherwise be private to external users).</p>
<p>Component的创建上下文对应于声明Component的上下文。当组件由诸如<a href="../qtquick/qml-qtquick-listview.html">ListView</a>或Loader之类的对象实例化时，此上下文用作父上下文（创建<a href="qtqml-documents-scope.html#component-instance-hierarchy">上下文层次结构</a>）。</p>
<p>在以下示例中，comp1在MyItem.qml的根上下文中创建，并且从该组件实例化的任何对象都可以访问该上下文中的id和属性，例如internalSettings.color。当在另一个上下文中comp1用作<a href="../qtquick/qml-qtquick-listview.html">ListView</a>委托时（如下面的main.qml中所示），它将继续访问其创建上下文的属性（否则对外部用户是私有的）。</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td >MyItem.qml</td><td ><pre class="qml">

  <span class="type"><a href="../qtquick/qml-qtquick-item.html">Item</a></span> {
      property <span class="type"><a href="qml-qtqml-component.html">Component</a></span> <span class="name">mycomponent</span>: <span class="name">comp1</span>

      <span class="type"><a href="qml-qtqml-qtobject.html">QtObject</a></span> {
          <span class="name">id</span>: <span class="name">internalSettings</span>
          property <span class="type"><a href="../qtquick/qml-color.html">color</a></span> <span class="name">color</span>: <span class="string">&quot;green&quot;</span>
      }

      <span class="type"><a href="qml-qtqml-component.html">Component</a></span> {
          <span class="name">id</span>: <span class="name">comp1</span>
          <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a></span> { <span class="name">color</span>: <span class="name">internalSettings</span>.<span class="name">color</span>; <span class="name">width</span>: <span class="number">400</span>; <span class="name">height</span>: <span class="number">50</span> }
      }
  }

</pre>
</td></tr>
<tr valign="top" class="even"><td >main.qml</td><td ><pre class="qml"><a>ListView</a> {
      width: 400; height: 400
      model: 5
       //会创建绿色矩形
      delegate: myItem.mycomponent    //will create green Rectangles

      MyItem { id: myItem }
  }

</pre>
</td></tr>
</table></div>
<p>It is important that the lifetime of the creation context outlive any created objects. See <a href="qtqml-javascript-dynamicobjectcreation.html#maintaining-dynamically-created-objects">Maintaining Dynamically Created Objects</a> for more details.</p>
重要的是，创建上下文的生命周期比任何创建的对象都要长。有关更多详细信息，请参阅<a href="qtqml-javascript-dynamicobjectcreation.html#maintaining-dynamically-created-objects">维护动态创建的对象</a>。<!-- @@@Component -->
<h2>Property Documentation （属性文档）</h2>
<!-- $$$progress -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="progress-prop">
<td class="tblQmlPropNode"><p>
<a name="progress-prop"></a><span class="name">progress</span> : <span class="type"><a href="qml-real.html">real</a></span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>The progress of loading the component, from 0.0 (nothing loaded) to 1.0 (finished).</p>
  加载组件的进度，从0.0（无加载）到1.0（已完成）</div></div><!-- @@@progress -->
<br/>
<!-- $$$status -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="status-prop">
<td class="tblQmlPropNode"><p>
<a name="status-prop"></a><span class="name">status</span> : <span class="type"><a href="qml-enumeration.html">enumeration</a></span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>This property holds the status of component loading. The status can be one of the following:</p>
<ul>
<li>Component.Null - no data is available for the component</li>
<li>Component.Ready - the component has been loaded, and can be used to create instances.</li>
<li>Component.Loading - the component is currently being loaded</li>
<li>Component.Error - an error occurred while loading the component. Calling <a href="qml-qtqml-component.html#errorString-method">errorString()</a> will provide a human-readable description of any errors.</li>
<div>
  <div>
    <p>此属性保存组件加载的状态。状态可以是以下之一：</p>
    <ul>
      <li>Component.Null - 组件没有可用数据</li>
      <li>Component.Ready - 组件已加载，可用于创建实例。</li>
      <li>Component.Loading - 当前正在加载组件</li>
      <li>Component.Error - 加载组件时发生错误。调用<a href="qml-qtqml-component.html#errorString-method">errorString（）</a>将提供任何错误的可读描述。</li>
    </ul>
  </div>
</div>
<br>
</ul>
</div></div><!-- @@@status -->
<br/>
<!-- $$$url -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="url-prop">
<td class="tblQmlPropNode"><p>
<a name="url-prop"></a><span class="name">url</span> : <span class="type"><a href="qml-url.html">url</a></span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>The component URL. This is the URL that was used to construct the component.</p>
  组件URL。这是用于构造组件的URL。</div></div><!-- @@@url -->
<br/>
<h2>Attached Signal Documentation （附加信号文档）</h2>
<!-- $$$completed -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="completed-signal">
<td class="tblQmlFuncNode"><p> <a></a>completed() --（已完成）</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Emitted after the object has been instantiated. This can be used to execute script code at startup, once the full QML environment has been established.</p>
<p>The corresponding handler is <code>onCompleted</code>. It can be declared on any object. The order of running the <code>onCompleted</code> handlers is undefined.</p>
<p>在实例化对象后发出。一旦建立完整的QML环境，这可以用于在启动时执行脚本代码。</p>
<p>相应的处理程序是onCompleted。它可以在任何对象上声明。运行onCompleted处理程序的顺序未定义。</p>
<pre class="qml">

  <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a></span> {
      <span class="name">Component</span>.onCompleted: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Completed Running!&quot;</span>)
      <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">Component</span>.onCompleted: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Nested Completed Running!&quot;</span>)
      }
  }

</pre>
</div></div><!-- @@@completed -->
<br/>
<!-- $$$destruction -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="destruction-signal">
<td class="tblQmlFuncNode"><p> <a></a>destruction() -- （摧毁）</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Emitted as the object begins destruction. This can be used to undo work done in response to the <a href="qml-qtqml-component.html#completed-signal">completed()</a> signal, or other imperative code in your application.</p>
<p>The corresponding handler is <code>onDestruction</code>. It can be declared on any object. The order of running the <code>onDestruction</code> handlers is undefined.</p>
<p>当对象开始破坏时发射。这可用于撤消响应<a href="qml-qtqml-component.html#completed-signal">completed（）</a>信号或应用程序中的其他命令性代码所做的工作。</p>
<p>相应的处理程序是onDestruction。它可以在任何对象上声明。运行onDestruction处理程序的顺序未定义。</p>
<pre class="qml">

  <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a></span> {
      <span class="name">Component</span>.onDestruction: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Destruction Beginning!&quot;</span>)
      <span class="type"><a href="../qtquick/qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">Component</span>.onDestruction: <span class="name">console</span>.<span class="name">log</span>(<span class="string">&quot;Nested Destruction Beginning!&quot;</span>)
      }
  }

</pre>
<p><b>See also </b><a href="qtqml-index.html">Qt QML</a>.</p>
<strong>另见</strong><a href="qtqml-index.html">Qt QML</a>。</div></div><!-- @@@destruction -->
<br/>
<h2>Method Documentation （方法文档）</h2>
<!-- $$$createObject -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="createObject-method">
<td class="tblQmlFuncNode"><p>
<a name="createObject-method"></a><span class="type">object</span> <span class="name">createObject</span>(<span class="type"><a href="qml-qtqml-qtobject.html">QtObject</a></span> <i>parent</i>,  <span class="type">object</span> <i>properties</i>)</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Creates and returns an object instance of this component that will have the given <i>parent</i> and <i>properties</i>. The <i>properties</i> argument is optional. Returns null if object creation fails.</p>
<p>The object will be created in the same context as the one in which the component was created. This function will always return null when called on components which were not created in QML.</p>
<p>If you wish to create an object without setting a parent, specify <code>null</code> for the <i>parent</i> value. Note that if the returned object is to be displayed, you must provide a valid <i>parent</i> value or set the returned object's <a href="../qtquick/qml-qtquick-item.html#parent-prop">parent</a> property, otherwise the object will not be visible.</p>
<p>If a <i>parent</i> is not provided to createObject(), a reference to the returned object must be held so that it is not destroyed by the garbage collector. This is true regardless of whether <a href="../qtquick/qml-qtquick-item.html#parent-prop">Item::parent</a> is set afterwards, because setting the Item parent does not change object ownership. Only the graphical parent is changed.</p>
<p>As of <code>QtQuick 1.1</code>, this method accepts an optional <i>properties</i> argument that specifies a map of initial property values for the created object. These values are applied before the object creation is finalized. This is more efficient than setting property values after object creation, particularly where large sets of property values are defined, and also allows property bindings to be set up (using <a href="qml-qtqml-qt.html#binding-method">Qt.binding</a>) before the object is created.</p>
<p>The <i>properties</i> argument is specified as a map of property-value items. For example, the code below creates an object with initial <code>x</code> and <code>y</code> values of 100 and 100, respectively:</p>
<p>创建并返回将具有给定<em>父级</em>和<em>属性</em>的此组件的对象实例。在<em>性能</em>参数是可选。如果对象创建失败，则返回null。</p>
<p>将在与创建组件的上下文相同的上下文中创建对象。在未在QML中创建的组件上调用时，此函数将始终返回null。</p>
<p>如果你想不设置父创建一个对象，指定null的<em>父</em>值。请注意，如果要显示返回的对象，则必须提供有效的<em>父</em>值或设置返回的对象的<a href="../qtquick/qml-qtquick-item.html#parent-prop">父</a>&nbsp;<a href="../qtquick/qml-qtquick-item.html#parent-prop">（parent）</a> 属性，否则该对象将不可见。</p>
<p>如果未向createObject（）提供<em>父级，</em>则必须保留对返回对象的引用，以便垃圾收集器不会销毁它。无论之后是否设置了<a href="../qtquick/qml-qtquick-item.html#parent-prop">Item :: parent，</a>都是如此，因为设置Item父级不会更改对象所有权。仅更改图形父级。</p>
<p>由于QtQuick 1.1，该方法接受一个可选的<em>属性</em>参数，指定地图上为所创建的对象的初始属性值。在完成对象创建之前应用这些值。这比在创建对象后设置属性值更有效，特别是在定义了大量属性值的情况下，并且还允许在创建对象之前设置属性绑定（使用<a href="qml-qtqml-qt.html#binding-method">Qt.binding</a>）。</p>
<p>的<em>特性</em>参数指定为地图的属性值的项目。例如，下面的代码创建具有初始的对象x和y的分别100和100，值：</p>
<pre class="js">

  var <span class="name">component</span> = <span class="name">Qt</span>.<span class="name">createComponent</span>(<span class="string">&quot;Button.qml&quot;</span>);
  <span class="keyword">if</span> (<span class="name">component</span>.<span class="name">status</span> <span class="operator">==</span> <span class="name">Component</span>.<span class="name">Ready</span>)
      <span class="name">component</span>.<span class="name">createObject</span>(<span class="name">parent</span>, {&quot;x&quot;: <span class="number">100</span>, &quot;y&quot;: <span class="number">100</span>});

</pre>
<p>Dynamically created instances can be deleted with the <code>destroy()</code> method. See <a href="qtqml-javascript-dynamicobjectcreation.html">Dynamic QML Object Creation from JavaScript</a> for more information.</p>
<p><b>See also </b><a href="qml-qtqml-component.html#incubateObject-method">incubateObject()</a>.</p>
<p>可以使用该destroy()方法删除动态创建的实例。有关详细信息，请参阅<a href="qtqml-javascript-dynamicobjectcreation.html">从JavaScript动态QML对象创建</a>。</p>
<p><strong>另请参见</strong><a href="qml-qtqml-component.html#incubateObject-method">incubateObject（）</a>。</p>
</div></div><!-- @@@createObject -->
<br/>
<!-- $$$errorString -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="errorString-method">
<td class="tblQmlFuncNode"><p>
<a name="errorString-method"></a><span class="type"><a href="qml-string.html">string</a></span> <span class="name">errorString</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Returns a human-readable description of any error.</p>
<p>The string includes the file, location, and description of each error. If multiple errors are present, they are separated by a newline character.</p>
<p>If no errors are present, an empty string is returned.</p>
<p>返回任何错误的可读描述。</p>
<p>该字符串包括每个错误的文件，位置和描述。如果存在多个错误，则它们由换行符分隔。</p>
<p>如果不存在错误，则返回空字符串。</p>
</div></div><!-- @@@errorString -->
<br/>
<!-- $$$incubateObject -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="incubateObject-method">
<td class="tblQmlFuncNode"><p>
<a name="incubateObject-method"></a><span class="type">object</span> <span class="name">incubateObject</span>(<span class="type"><a href="../qtquick/qml-qtquick-item.html">Item</a></span> <i>parent</i>,  <span class="type">object</span> <i>properties</i>,  <span class="type"><a href="qml-enumeration.html">enumeration</a></span> <i>mode</i>)</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Creates an incubator for an instance of this component. Incubators allow new component instances to be instantiated asynchronously and do not cause freezes in the UI.</p>
<p>The <i>parent</i> argument specifies the parent the created instance will have. Omitting the parameter or passing null will create an object with no parent. In this case, a reference to the created object must be held so that it is not destroyed by the garbage collector.</p>
<p>The <i>properties</i> argument is specified as a map of property-value items which will be set on the created object during its construction. <i>mode</i> may be Qt.Synchronous or Qt.Asynchronous, and controls whether the instance is created synchronously or asynchronously. The default is asynchronous. In some circumstances, even if Qt.Synchronous is specified, the incubator may create the object asynchronously. This happens if the component calling incubateObject() is itself being created asynchronously.</p>
<p>All three arguments are optional.</p>
<p>If successful, the method returns an incubator, otherwise null. The incubator has the following properties:</p>
<ul>
<li>status The status of the incubator. Valid values are Component.Ready, Component.Loading and Component.Error.</li>
<li>object The created object instance. Will only be available once the incubator is in the Ready status.</li>
<li>onStatusChanged Specifies a callback function to be invoked when the status changes. The status is passed as a parameter to the callback.</li>
<li>forceCompletion() Call to complete incubation synchronously.</li>
</ul>
<p>The following example demonstrates how to use an incubator:</p>
<p>为此组件的实例创建一个孵化器。孵化器允许异步实例化新组件实例，并且不会导致UI冻结。</p>
<p>该<em>父</em>参数指定父创建的实例都会有。省略参数或传递null将创建一个没有父对象的对象。在这种情况下，必须保持对创建的对象的引用，以便垃圾收集器不会销毁它。</p>
<p>的<em>特性</em>参数指定为地图属性值的项的，这将被创建的对象在其施工过程中设定。<em>mode</em>可以是Qt.Synchronous或Qt.Asynchronous，并控制实例是同步创建还是异步创建。默认值是异步的。在某些情况下，即使指定了Qt.Synchronous，孵化器也可以异步创建对象。如果调用incubateObject（）的组件本身是异步创建的，则会发生这种情况。</p>
<p>所有三个参数都是可选的。</p>
<p>如果成功，该方法返回一个孵化器，否则返回null。孵化器具有以下特性：</p>
<ul>
  <li>status孵化器的状态。有效值为Component.Ready，Component.Loading和Component.Error。</li>
  <li>object创建的对象实例。只有在孵化器处于就绪状态时才可用。</li>
  <li>onStatusChanged指定状态更改时要调用的回调函数。状态作为参数传递给回调。</li>
  <li>forceCompletion（）调用同步完成孵化。</li>
</ul>
<p>以下示例演示了如何使用孵化器：</p>
<pre class="js">

  var <span class="name">component</span> = <span class="name">Qt</span>.<span class="name">createComponent</span>(<span class="string">&quot;Button.qml&quot;</span>);

  var <span class="name">incubator</span> = <span class="name">component</span>.<span class="name">incubateObject</span>(<span class="name">parent</span>, { x: <span class="number">10</span>, y: <span class="number">10</span> });
  <span class="keyword">if</span> (<span class="name">incubator</span>.<span class="name">status</span> <span class="operator">!=</span> <span class="name">Component</span>.<span class="name">Ready</span>) {
      <span class="name">incubator</span>.<span class="name">onStatusChanged</span> <span class="operator">=</span> <span class="keyword">function</span>(<span class="name">status</span>) {
          <span class="keyword">if</span> (<span class="name">status</span> <span class="operator">==</span> <span class="name">Component</span>.<span class="name">Ready</span>) {
              <span class="name">print</span> (<span class="string">&quot;Object&quot;</span>, <span class="name">incubator</span>.<span class="name">object</span>, <span class="string">&quot;is now ready!&quot;</span>);
          }
      }
  } <span class="keyword">else</span> {
      <span class="name">print</span> (<span class="string">&quot;Object&quot;</span>, <span class="name">incubator</span>.<span class="name">object</span>, <span class="string">&quot;is ready immediately!&quot;</span>);
  }

</pre>
<p>Dynamically created instances can be deleted with the <code>destroy()</code> method. See <a href="qtqml-javascript-dynamicobjectcreation.html">Dynamic QML Object Creation from JavaScript</a> for more information.</p>
<p><b>See also </b><a href="qml-qtqml-component.html#createObject-method">createObject()</a>.</p>
<p>可以使用该destroy()方法删除动态创建的实例。有关详细信息，请参阅<a href="qtqml-javascript-dynamicobjectcreation.html">从JavaScript动态QML对象创建</a>。</p>
<p><strong>另请参见</strong><a href="qml-qtqml-component.html#createObject-method">createObject（）</a>。</p>
</div></div><!-- @@@incubateObject -->
<br/>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2018 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
